<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kahin Market</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');
        html, body { 
            margin: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Roboto', sans-serif !important; 
            color: white;
            background: #111;
        }
        #magic {
            position: fixed;
            width: 100%;
            height: 100vh;
            display: block;
            top: 0;
            left: 0;
            z-index: -1;
        }
        .playground {
            position: fixed;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
        }
        .bottomPosition {
            text-align: center;
            margin-bottom: 50px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <div id="magic"></div>
    <div class="playground">
        <div class="bottomPosition">
           <div class="minText">Yakında Hizmetinizde!</div>
        </div>
    </div>
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; varying vec3 vColor;
        void main() { vColor = customColor; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_PointSize = size * ( 300.0 / -mvPosition.z ); gl_Position = projectionMatrix * mvPosition; }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color; uniform sampler2D pointTexture; varying vec3 vColor;
        void main() { gl_FragColor = vec4( color * vColor, 1.0 ); gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord ); }
    </script>

    <script>
        // --- YENİ, DAHA SAĞLAM KOD ---
        document.addEventListener("DOMContentLoaded", () => {
            console.log("[KAHIN] Adım 1: Sayfa yüklendi (DOMContentLoaded). Animasyon başlatılıyor...");
            try {
                if (typeof THREE === 'undefined') {
                    console.error("[KAHIN HATA] Three.js kütüphanesi yüklenemedi!");
                    return;
                }
                console.log("[KAHIN] Adım 2: Three.js kütüphanesi bulundu. Sürüm: " + THREE.REVISION);

                let manager = new THREE.LoadingManager();
                var typo = null;
                var particle = null;

                manager.onLoad = function() { 
                    console.log("[KAHIN] Adım 3: Tüm harici dosyalar (font, resim) başarıyla yüklendi.");
                    if(typo && particle) {
                        const environment = new Environment(typo, particle);
                    } else {
                        console.error("[KAHIN HATA] Font veya parçacık resmi yüklenmiş olsa da değişkenlere atanamadı.");
                    }
                }
                manager.onError = function(url) {
                    console.error('[KAHIN HATA] Şu dosya yüklenemedi: ' + url);
                }

                console.log("[KAHIN] Adım 2.1: Font ve parçacık resmi yüklenmeye başlıyor...");
                const fontLoader = new THREE.FontLoader(manager);
                fontLoader.load('https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json', function (font) { typo = font; });
                
                const particleLoader = new THREE.TextureLoader(manager);
                particleLoader.setCrossOrigin("anonymous");
                particle = particleLoader.load('https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png');
                
                // ... (Geriye kalan class'lar ve kod aynı, sadece loglama eklendi)
                class Environment {
                    constructor(font, particle) { 
                        console.log("[KAHIN] Adım 4: Environment class'ı başlatılıyor...");
                        this.font = font; this.particle = particle; this.container = document.querySelector('#magic');
                        this.scene = new THREE.Scene(); this.createCamera(); this.createRenderer(); this.setup(); this.bindEvents();
                    }
                    bindEvents(){ window.addEventListener('resize', this.onWindowResize.bind(this)); }
                    setup(){ 
                        console.log("[KAHIN] Adım 5: Parçacıklar oluşturuluyor...");
                        this.createParticles = new CreateParticles(this.scene, this.font, this.particle, this.camera, this.renderer); 
                    }
                    render() { this.createParticles.render(); this.renderer.render(this.scene, this.camera); }
                    createCamera() { this.camera = new THREE.PerspectiveCamera(65, this.container.clientWidth / this.container.clientHeight, 1, 10000); this.camera.position.set(0, 0, 100); }
                    createRenderer() {
                        this.renderer = new THREE.WebGLRenderer({ antialias: true }); this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); this.renderer.outputEncoding = THREE.sRGBEncoding;
                        this.container.appendChild(this.renderer.domElement); this.renderer.setAnimationLoop(() => { this.render() });
                    }
                    onWindowResize() { this.camera.aspect = this.container.clientWidth / this.container.clientHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(this.container.clientWidth, this.container.clientHeight); }
                }
                class CreateParticles {
                     constructor(scene, font, particleImg, camera, renderer) {
                        console.log("[KAHIN] Adım 6: CreateParticles class'ı başlatılıyor...");
                        this.scene = scene; this.font = font; this.particleImg = particleImg; this.camera = camera; this.renderer = renderer;
                        this.raycaster = new THREE.Raycaster(); this.mouse = new THREE.Vector2(-200, 200); this.colorChange = new THREE.Color();
                        this.buttom = false;
                        this.data = { text: 'KAHIN\nMARKET', amount: 1500, particleSize: 1, particleColor: 0xffffff, textSize: 16, area: 250, ease: 0.05, };
                        this.setup(); this.bindEvents();
                    }
                    setup(){
                        const geometry = new THREE.PlaneGeometry(this.visibleWidthAtZDepth(100, this.camera), this.visibleHeightAtZDepth(100, this.camera));
                        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true }); this.planeArea = new THREE.Mesh(geometry, material);
                        this.planeArea.visible = false; this.createText();
                    }
                    bindEvents(){ document.addEventListener('mousedown', this.onMouseDown.bind(this)); document.addEventListener('mousemove', this.onMouseMove.bind(this)); document.addEventListener('mouseup', this.onMouseUp.bind(this));}
                    onMouseDown(event) { this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5); vector.unproject(this.camera); const dir = vector.sub(this.camera.position).normalize(); const distance = -this.camera.position.z / dir.z; this.currenPosition = this.camera.position.clone().add(dir.multiplyScalar(distance)); this.buttom = true; this.data.ease = 0.01; }
                    onMouseUp() { this.buttom = false; this.data.ease = 0.05; }
                    onMouseMove(event) { this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1; this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; }
                    render() {
                        const time = ((.001 * performance.now()) % 12) / 12; const zigzagTime = (1 + (Math.sin(time * 2 * Math.PI))) / 6;
                        this.raycaster.setFromCamera(this.mouse, this.camera); const intersects = this.raycaster.intersectObject(this.planeArea);
                        if (intersects.length > 0) {
                            const pos = this.particles.geometry.attributes.position; const copy = this.geometryCopy.attributes.position; const coulors = this.particles.geometry.attributes.customColor; const size = this.particles.geometry.attributes.size;
                            const mx = intersects[0].point.x; const my = intersects[0].point.y;
                            for (var i = 0, l = pos.count; i < l; i++) {
                                const initX = copy.getX(i); const initY = copy.getY(i); const initZ = copy.getZ(i);
                                let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);
                                this.colorChange.setHSL(.5 + zigzagTime, 1, .5); coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b); coulors.needsUpdate = true;
                                size.setX(i, this.data.particleSize); size.needsUpdate = true;
                                let dx = mx - px; let dy = my - py; const d = (dx * dx) + (dy * dy); const f = -this.data.area / d;
                                if (this.buttom) { const t = Math.atan2(dy, dx); px -= f * Math.cos(t); py -= f * Math.sin(t); } 
                                else if (this.distance(mx, my, px, py) < this.data.area) {
                                    if (i % 5 == 0) { const t = Math.atan2(dy, dx); px -= .03 * Math.cos(t); py -= .03 * Math.sin(t); } 
                                    else { const t = Math.atan2(dy, dx); px += f * Math.cos(t); py += f * Math.sin(t); }
                                }
                                px += (initX - px) * this.data.ease; py += (initY - py) * this.data.ease; pz += (initZ - pz) * this.data.ease;
                                pos.setXYZ(i, px, py, pz); pos.needsUpdate = true;
                            }
                        }
                    }
                    createText() { 
                        console.log("[KAHIN] Adım 7: createText() fonksiyonu çalışıyor. Parçacıklar yazıya göre şekillendiriliyor...");
                        let thePoints = []; let shapes = this.font.generateShapes(this.data.text, this.data.textSize);
                        let geometry = new THREE.ShapeGeometry(shapes); geometry.computeBoundingBox();
                        const xMid = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x); const yMid = 0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y);
                        geometry.center(); let holeShapes = [];
                        for (let q = 0; q < shapes.length; q++) { let shape = shapes[q]; if (shape.holes && shape.holes.length > 0) { for (let j = 0; j < shape.holes.length; j++) { holeShapes.push(shape.holes[j]); } } }
                        shapes.push.apply(shapes, holeShapes); let colors = []; let sizes = [];
                        for (let x = 0; x < shapes.length; x++) {
                            let shape = shapes[x]; const amountPoints = (shape.type == 'Path') ? this.data.amount / 2 : this.data.amount;
                            let points = shape.getPoints(amountPoints);
                            points.forEach((element) => {
                                const a = new THREE.Vector3(element.x, element.y, 0); thePoints.push(a);
                                colors.push(this.colorChange.r, this.colorChange.g, this.colorChange.b); sizes.push(1);
                            });
                        }
                        let geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints); geoParticles.translate(xMid, yMid, 0);
                        geoParticles.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3)); geoParticles.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                        const material = new THREE.ShaderMaterial({
                            uniforms: { color: { value: new THREE.Color(0xffffff) }, pointTexture: { value: this.particleImg } },
                            vertexShader: document.getElementById('vertexshader').textContent, fragmentShader: document.getElementById('fragmentshader').textContent,
                            blending: THREE.AdditiveBlending, depthTest: false, transparent: true,
                        });
                        this.particles = new THREE.Points(geoParticles, material); this.scene.add(this.particles);
                        this.geometryCopy = new THREE.BufferGeometry(); this.geometryCopy.copy(this.particles.geometry);
                        console.log("[KAHIN] Adım 8: Parçacıklar oluşturuldu ve sahneye eklendi. Animasyon başlamalı.");
                    }
                    visibleHeightAtZDepth(depth, camera) { const cameraOffset = camera.position.z; if (depth < cameraOffset) depth -= cameraOffset; else depth += cameraOffset; const vFOV = camera.fov * Math.PI / 180; return 2 * Math.tan(vFOV / 2) * Math.abs(depth); }
                    visibleWidthAtZDepth(depth, camera) { const height = this.visibleHeightAtZDepth(depth, camera); return height * camera.aspect; }
                    distance(x1, y1, x2, y2) { return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2)); }
                }
            } catch (e) {
                console.error("[KAHIN KRİTİK HATA]", e);
                alert("Animasyon başlatılırken kritik bir hata oluştu. Lütfen konsolu kontrol edin.");
            }
        });
    </script>

</body>
</html>